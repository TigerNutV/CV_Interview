*本文内容仅为图像算法工程师所需掌握的C++基础，不足之处请指出*

*作者：chenhan*

*时间：2025.01.07*



1. 语法与关键特性

基本数据类型与指针/引用的区别：

**基本数据类型**int\float\char\bool等用于存储数据值本身，通常根据声明的方式，存放在内存的栈区或静态数据区

**指针**是变量，用于存放另一个变量的地址；**引用**与被引用变量位于同一内存区域，没有独立存储空间



函数与函数重载，默认参数

**函数重载**在同一作用域内，可以有多个重名函数，只要参数列表不同即可（类型、数量或是顺序不同都可）。同一作用域意味着相同的可见性和生命周期。

**默认参数**允许函数在声明和定义中指定默认值，若调用时未提供默认值，则使用默认值，注意必须从右至左指定



类、对象、构造函数和析构函数

**类**为自定义的数据类型，是一种封装机制；**对象**为类的实例

**构造函数**初始化对象状态，对于常量和引用成员必须在构造函数中进行初始化，最好是初始化所有成员变量

**析构函数**在对象生命周期结束后调用，大型项目里通常放在实现中



内联函数的应用场景和实现原理

内联函数的**应用场景**:

小型函数的使用，内联函数的使用可以避免函数调用的开销，提升性能；

`inline int add(int a, int b){`

`return a+b;}`

模板函数的使用，内联函数用于实现模板的内联展开，避免模板实例化过程中的函数调用开销；

`template <template T>`

`inlier T max(T a, T b){`

`return a>b ? a:b;}`

内联函数的**实现原理**：内联函数将函数定义直接插入到调用点，省去参数传递、栈帧创建、返回地址保存等操作，注意内联适用于小型函数，递归不可，虚函数不可内联。



2. 内存管理

内存是计算机存储数据和程序指令的硬件资源，简单来说是用来存储正在运行的程序和数据，是CPU可以直接访问的存储区域

栈和堆的区别

**栈**存储局部变量、函数参数、返回地址和函数调用的上下文信息。栈的大小有限，不适合存储大量数据，若局部变量过多或过深的递归调用会导致栈溢出

**堆**用于动态内存分配，存储对象的生命周期不固定的数据，堆上的数据访问速度较慢，不释放会导致内存泄漏



动态内存的分配和释放（new/delete ,malloc/free）

对于动态内存的分配，C++和C中分别使用的是new/delete和malloc/free，

**new/delete**，new会自动分配内存大小，对于类类型，new会调用对象的构造函数，delete会调用对象的析构函数，new返回的是指向分配类型的指针 Type* 无需进行类型转换，内存分配失败会抛出异常std::bad_alloc；

**malloc/free**，malloc需要手动计算内存，malloc/free不会自动调用构造和析构函数，malloc返回的是void*，需要进行类型转换，若内存分配失败，返回nullptr，不会抛出异常,malloc会默认多分配16个字节的空间。



常见内存泄露问题与调试

忘记释放内存（记得delete）；

循环引用：循环引用通常发生在智能指针中，尤其是std::shared_ptr，该智能指针通过引用计数管理指针的生命周期，当计数为0时将自动删除，然而当两个或多个对象互相引用时，则引用计数永远不会清零，从而导致内存泄露

` std::weak_ptr`可解决互相引用问题

`#include <iostream>`

`#include<memory>`

`class B;`

`class A{`

`public:`

​	`std::shared_ptr<B>bptr;`

​	`~A(){`

​		`std::cout<<"A destructor called"<<std::endl;`

​	`}};`

`class B{`

`public:`

​	`std::shared_ptr<A>aptr;`

​	`~B(){`

​		`std::cout<<""<<std::endl;`

`}};`

`int main(){`

​	`std::shared_ptr<A> a = std::make_shared<A>();`

​	`std::shared_ptr<B> b = std::make_shared<B>();`

​	`a->bptr = b;`

​	`b->aptr = a;`

​	`return 0;`

`}`

3. 输入输出

标准输入输出流（`cin`, `cout`, `cerr` 等）

std::fstream、std::ofstream、std::ifstream - 读写 写 读，而后使用is_open检查